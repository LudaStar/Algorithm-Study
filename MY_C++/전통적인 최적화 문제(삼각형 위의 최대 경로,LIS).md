### 삼각형 위의 최대 경로

	6
	1  2
	3  7  4
	9  4  1  7
	2  7  5  9  4
위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요.

### 입력

입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 삼각형의 크기 n(2 <= n <= 100)이 주어지고, 그 후 n줄에는 각 1개~n개의 숫자로 삼각형 각 가로줄에 있는 숫자가 왼쪽부터 주어집니다. 각 숫자는 1 이상 100000 이하의 자연수입니다.

### 출력

각 테스트 케이스 마다 한 줄에 최대 경로의 숫자 합을 출력합니다.

### 예제 입력

	2
	5
	6
	1  2
	3  7  4
	9  4  1  7
	2  7  5  9  4
	5
	1 
	2 4
	8 16 8
	32 64 32 64
	128 256 128 256 128

### 예제 출력
	28
	341

### 문제 접근 

분할 정복에서 배운 메모리제이션을 통해 계획할 수 있었다. 또한 이부분은 매우 간단하게 구현할 수 있ㅇㅆ다.

먼저 무조건 시작은 0,0부터 시작해서 아래로 1칸 아래 오른쪽으로 한칸만 움직일 수 있다. 이때 (y,x)가 움직일 수 있는 좌표는(y+1,x),(y+1,x+1)의 좌표 두개뿐이므로 둘 중에 가장 큰 값을 찾아서 이전 층에서나온 값중 가장 큰값에 더해주면 된다.

수식으로 나타내면 max((y+1,x),(y+1,x+1))+(이전에 계산된 (y,x)좌표값)이 된다 이 수식을 그대로 코드에 구현하면

```
int n;//삼각형의 높이
int cache2[100][100];//이미 계산된 수치를 저장할 값

int path2(int y, int x) {
	if (y == n - 1) return triangle[y][x];//기저사례 : 삼각형의 맨 아래층에 도달하면 triangle값을 반환
	int& ret = cache2[y][x];
	if (ret != -1) return ret;
	return ret = max(path2(y + 1, x), path2(y + 1, x + 1)) + triangle[y][x];// 수식 적용
}