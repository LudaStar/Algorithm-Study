# Quantization 문제

Quantization (양자화) 과정은, 더 넓은 범위를 갖는 값들을 작은 범위를 갖는 값들로 근사해 표현함으로써 자료를 손실 압축하는 과정을 말한다. 예를 들어 16비트 JPG 파일을 4컬러 GIF 파일로 변환하는 것은 RGB 색 공간의 색들을 4컬러 중의 하나로 양자화하는 것이고, 키가 161, 164, 170, 178 인 학생 넷을 '160대 둘, 170대 둘' 이라고 축약해 표현하는 것 또한 양자화라고 할 수 있다.

1000 이하의 자연수들로 구성된 수열을 최대 S종류 의 값만을 사용하도록 양자화하고 싶다. 이 때 양자화된 숫자는 원래 수열에 없는 숫자일 수도 있다. 양자화를 하는 방법은 여러 가지가 있다. 수열 1 2 3 4 5 6 7 8 9 10 을 2개의 숫자만을 써서 표현하려면, 3 3 3 3 3 7 7 7 7 7 과 같이 할 수도 있고, 1 1 1 1 1 10 10 10 10 10 으로 할 수도 있다. 우리는 이 중, 각 숫자별 오차 제곱의 합을 최소화하는 양자화 결과를 알고 싶다.

예를 들어, 수열 1 2 3 4 5 를 1 1 3 3 3 으로 양자화하면 오차 제곱의 합은 0+1+0+1+4=6 이 되고, 2 2 2 4 4 로 양자화하면 오차 제곱의 합은 1+0+1+0+1=3 이 된다.

수열과 S 가 주어질 때, 가능한 오차 제곱의 합의 최소값을 구하는 프로그램을 작성하시오.

## 입력

입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 50) 가 주어진다. 각 테스트 케이스의 첫 줄에는 수열의 길이 N (1 <= N <= 100), 사용할 숫자의 수 S (1 <= S <= 10) 이 주어진다. 그 다음 줄에 N개의 정수로 수열의 숫자들이 주어진다. 수열의 모든 수는 1000 이하의 자연수이다.

## 출력

각 테스트 케이스마다, 주어진 수열을 최대 S 개의 수로 양자화할 때 오차 제곱의 합의 최소값을 출력한다.

## 예제 입력

	2
	10 3
	3 3 3 1 2 3 2 2 2 1
	9 3
	1 744 755 4 897 902 890 6 777

## 예제 출력

	0
	651

## 문제 접근

이 문제를 보면 처음엔 시간내로 풀 수 없을 것 같았다. 왜냐하면 수열자체가 정돈되어있지도 않고 하나의 값으로 압축하기 위해서 많은 경우에 수를 구해봐야 했기 때문이다. 그런데 이런 생각을 하면서 일정 숫자들을 양자화(압축)을 하기위해서 굳이 나열된 수열대로 해야되나? 라는 생각을 했다.
그래서 나는 이 문제를 처음부터 정렬을 하게 되면 어떨까 라는 생각으로 접근을 해 보았다.

첫번째 예제 입력을 보면 3 3 3 1 2 3 2 2 2 1로 되어있는데 이 수열에서 정렬을 하게되면 1 1 2 2 2 2 3 3 3 3 이나오는데 이 값은 눈으로 보기에도 1 2 3 으로 양자화를 시켜 오차율이 0이 나오는 것을 확인 할 수있었다.

그래서 처음에 시작할때 정렬부터 들어가기로 했다.

문제를 정렬하고 나니 눈에 띄는 부분이 양자화 시킬 부분은 인접해있다 라는 사실을 알 수 있다. 이렇게 두고 생각하니 해당 구간을 m개의 구간으로 나누고 그 구간안의 오차율만 구하게 된다면 매우 간단하게 문제를 해결해 볼 수 있었다.

또한 구간별로 에러율은 서로 관계를 하지않으니 코드적으로도 매우 복잡하지 않다.

이제 할 일은 두가지 이다.

1. 주어진 구간을 어떠한 수 n으로 표현할 것인가
2. 주어진 구간을 n으로 표현했을 때 오차율을 구했을 때 최소값인가

이부분은 따로 함수로 만들 수 있게 되는것이다.

또한 주어진 구간을 미리 계산해 둔다면 매번 반복적으로 구하지 않아도 메모이제이션을 통해 빠른 계산 방식을 취득할 수 있다.

하지만 숫자가 1000개인데 1000개의 모든 구간을 구하게 된다면 시간적으로 구해지지 않는 경우도 있겠다 싶어서 다른 방법을 찾아보았다.

내가 생각한 방식은 구간의 모든 수의 평균을 두면 에러율이 최솟값일 것이라 예상한 것이었다.

예제의 두번째 예제의 1 744 755 4 897 902 890 6 777의 정렬된 수열 1 4 6 744 755 777 890 897 892를 계산해 보았을 때(눈으로 확인해도 어떻게 모아져야 할지 대강 보인다.) 1 4 6 = 4, 744 755 777 = 759, 890 890 902 = 896 이 나오는것을 확인 할 수있다.

코드는 다음과 같다.

## 코드
```
const int INF = 987654321;

int n;
int A[101], pSum[101], pSqSum[101];

void precalc() {
	sort(A, A + n);
	pSum[0] = A[0];
	pSqSum[0] = A[0] * A[0];
	for (int i = 1; i < n; ++i) {
		pSum[i] = pSum[i - 1] + A[i];
		pSqSum[i] = pSqSum[i - 1] + A[i] * A[i];
	}
}
```
여기서 n은 전체 수열의 길이이고 A는 주어진 수열, pSum은 구간 합, pSqSum은 부분 제곱 구간합이다. 이 때 제곱 구간합을 구하는 이유는 문제에서 볼 수 있듯이 오차제곱 합을 구하는 것이기 때문이다.
먼저 수열 A를 정렬해준 후 pSum,pSqSum을 먼저 계산해 둔다.

```
int minError(int lo, int hi) {
	int sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo - 1]);
	int sqSum = pSqSum[hi] - (lo == 0 ? 0 : pSqSum[lo - 1]);

	int m = int(0.5 + (double)sum / (hi - lo + 1));
	int ret = sqSum - 2 * m*sum + m * m*(hi - lo + 1);
	return ret;
}
```

에러율 구하는 부분은 어떤수 m으로 압축을 하는지 정하는 코드와 결정한 수 m으로 구하는 방법이다.

위에서 보면 ret부분에 왜 저런방식으로 구하냐 고 생각할 수 있는데 모든 수열을 for문으로 더하는 것보다 2차 제곱식을 이용해 계산하는것이 훨 씬빠르고 위에 메모이제이션을 활용하기 위한 방법이다. 편한 방법을 사용하면 된다.

```
int cache[101][101];

int quantize(int from, int parts) {
	//기저사례 : 모든 숫자를 다 양자화 했을 때
	if (from == n) return 0;
	//기저사례 : 숫자는 남아있는데 더 묶을 수 없을 때 아주 큰 값을 반환한다.
	if (parts == 0) return INF;

	int& ret = cache[from][parts];
	if (ret != -1) return ret;
	
	for (int partSize = 1; from + partSize <= n; ++partSize) {
		ret = min(ret, minError(from, from + partSize - 1)) + quantize(from + partSize, parts - 1);

	}
	return ret;
}
```

이제 드디어 양자화 부분이다.  코드를 보면 매우 간단하다. ret 부분에 min을 넣어 줌으로써 구간의 크기가 n이 될때 까지 양자화된 값을 구하는 것을 확인 할 수있다.

### 마치며

이 문제를 풀며 어려움을 많이 느꼈다. 그 이유는 문제 자체를 이해하는 것에도 시간이 걸렸고 문제를 해결하기 위해 여러 방법을 생각하다가 정렬이라는 키워드를 생각하기 전까지 고생을 꽤 했기 때문이다.

수학적으로 접근하는 부분이 많기때문에 수학적인 부분을 공부하는것도 좋은 방법일 듯 싶다. 