## 울타리 잘라내기 

### 문제
너비가 같은 N개의 나무 판자를 붙여 세운 울타리가 있습니다. 시간이 지남에 따라 판자들이 부러지거나 망가져 높이가 다 달라진 관계로 울타리를 통째로 교체하기로 했습니다. 이 때 버리는 울타리의 일부를 직사각형으로 잘라내 재활용하고 싶습니다. 그림 (b)는 (a)의 울타리에서 잘라낼 수 있는 많은 직사각형 중 가장 넓은 직사각형을 보여줍니다. 울타리를 구성하는 각 판자의 높이가 주어질 때, 잘라낼 수 있는 직사각형의 최대 크기를 계산하는 프로그램을 작성하세요. 단 (c)처럼 직사각형을 비스듬히 잘라낼 수는 없습니다.

판자의 너비는 모두 1이라고 가정합니다.

<img src = "https://algospot.com/media/judge-attachments/506874700c7251881727ee4e70a1d502/fence.png">

### 입력

첫 줄에 테스트 케이스의 개수 C (C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 판자의 수 N (1≤N≤20000)이 주어집니다. 그 다음 줄에는 N개의 정수로 왼쪽부터 각 판자의 높이가 순서대로 주어집니다. 높이는 모두 10,000 이하의 음이 아닌 정수입니다.
	3
	7
	7 1 5 9 6 7 3
	7
	1 4 4 4 4 1 1
	4
	1 8 2 2


### 출력

각 테스트 케이스당 정수 하나를 한 줄에 출력합니다. 이 정수는 주어진 울타리에서 잘라낼 수 있는 최대 직사각형의 크기를 나타내야 합니다.
	20
	16
	8

### 문제 접근

처음 이 문제를 접했을 때 가장 왼쪽의 높이를 최대 높이라고 하고 계산을 하면 무식하게 계산이 가능하다.

하지만 제한 시간이 1초안에 해결해 나가야하는데 2중 포문으로 만들경우 2만개를 두번계산해야하는데 그러면 제한시간을 초과하게 될것입니다.

2중 포문으로 만드는 코드는 매우 간단합니다.

```

int bruteForce(const vector<int>& h) {
	int ret = 0;
	int N = h.size();

	for (int i = 0; i < N; i++) {
		int minLeft = h[i];
		for (int j = i; j < N; j++) {
			minLeft = min(minLeft, h[j]);
			ret = max(ret, (i - j + 1)*minLeft);
		}
	}
}
```
이중포문 두번으로 계산이 가능하지만 제한시간을 초과하니 다른 방법을 생각해야합니다.

이때 생각할 수 있는 부분은 가운데부터 시작해서 시작부분을 정하고 차차 크기를 늘려가면서 최종적으로 가장 큰 직사각형을 만들면 됩니다.

조건은 다음과 같습니다.

* 가장 큰 직사각형을 왼쪽 부분 문제에서만 잘라낼 수 있다.
* 가장 큰 직사각형을 오른쪽 부분 문제에서만 잘라낼 수 있다.
* 가장 큰 직사각형은 양쪽에 걸쳐있다.

이렇게 조건을 걸고 코드부분을 해결해 보자.

```
	if (left == right) return h[left];

	int mid = (left + right) / 2;

	int ret = max(RefreshFence(left, mid), RefreshFence(mid, right);

	int lo = mid, hi = mid + 1;

	int height = min(h[lo], h[hi]);

	ret = max(ret, height);
```
처음 if 문에서 왼쪽과 오른쪽의 높이가 같다면 둘 중 아무거나 반환해도 상관없으니 아무 값이나 반환을 합니다.

그다음에 가운데 부분을 정해서 가장 큰 값을 가져오는 결과값을 가져옵니다.

이후에 오른쪽 부분인 hi, 왼쪽 부분인 lo로 나누어 답을 찾기를 시작합니다.

```
while (left < lo || hi < right) {//왼쪽이 lo보다 작거나 오른쪽이 hi보다 크다면 반복문을 계속한다.
		if (hi < right && (lo == left || h[lo - 1] < h[hi + 1])) {
			hi++;
			height = min(height, h[hi]);
		}
		else {
			--lo;
			height = min(h[lo], height);
		}
		ret = max(ret, height *(hi - lo + 1));
	}
```
왼쪽에서 시작하거나 오른쪽에서 시작하거나 시작 위치를 찾는것은 상관이 없습니다. 그저 반복할 시간이 절반 이하로 떨어지는게 좋은 코드입니다.



### 마치며

위 코드를보면 재귀 함수를 통해 분할 정복을 하는것을 확인할 수 있는데 이렇게 양쪽으로 시작하게 된다면 총 시간 복잡도는 O(n)이 됩니다.

이중 포문을 사용했을 때인 O(n<sup>2</sup>)보다 훨씬 작은 값임을 알 수 있습니다.

재귀함수의 사용법을 좀더 익히고 반복함에 따라 좀더 나은 코드를 작성해 보려 한다.
