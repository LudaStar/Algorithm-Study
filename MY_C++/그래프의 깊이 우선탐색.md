# 그래프의 깊이 우선 탐색

그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법입니다. 현재 정점과 인접한 간선들을 하나씩 검사하다가, 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 무조건 따라가는 방식이다
이 과정에서 더이상 갈 곳이 없는 막힌 정점에 도달하면 포기하고 마지막에 따라왔던 간선으 따라 뒤로 돌아간다.

그래프의 깊이 우선 탐색이 어떻게 이루어지는지 확인해 보자. 정점 s에서 탐색을 시작한다면 각 인접한 정점들을 알파벳 순서대로 검사한다고 한다. 이에 따르면 깊이 우선 탐색이 처음 검사하는 간서은 (s,a)이다. 탐색 과정에서 a에 방문한 적이 없기 때문에 깊이 우선 탐색은 a로 움직인다. 같은 원리로 b,c로 가는 경로를 찾고 나면 더이상 갈 길이 없음을 알 수 있다. c에서 나가는 유일한 경로는 a로 돌아가는 것 뿐인데 a는 이미 방문한 뒤이기 때문이다. 따라서 마지막에 따라온 (b,c) 간선을 따라 뒤로 돌아간 뒤 b에서 다시 방문하지 않은 정점이 있나 확인한다. 방문하지 않은 정점 d가 있으므로 이쪽을 방문하고 갈 정점이 업승면 돌아온다. 
e와 f도 이렇게 방문하고 나면 b에서 갈 정점이 없으므로 (a,b)로 돌아온다.

이렇듯 깊이 우선 탐색은 탐색의 각 과정에서 가능한 한 그래프 안으로 깊이 들어가려고 시도하고 막힌 정점에 도달하지 않는 한 뒤로 돌아오지 않는다.

다음의 코드를 확인하자

```
//그래프의 인접 리스트
vector<vector<int>> adj;
//각 지점을 방문했는지 여부를 나타낸다.
vector<bool> visited;
//깊이 우선 탐색을 구현

void dfs(int here) {
	cout << "DFS visits" << here << endl;
	visited[here] = true;
	for (int i = 0; i < adj[here].size(); ++i) {
		int there = adj[here][i];
		if (!visited[there])
			dfs(there);
	}
	//더이상 방문할 정점이 없으니 재귀호출 종료하고 이전 정점으로
}


//모든 정점을 방문

void dfsAll() {
	//visited를 모두 valse로 초기화.
	visited = vector<bool>(adj.size(), false);
	for (int i = 0; i < adj.size(); ++i)
		if (!visited[i])
			dfs(i);   
}
```
여기서 가장 유의해야 할 점은 모든 정점에 대해 순서대로 dfs() 를 호출하는 dfsAll()함수다. 그래프에서는 모든 정점들이 간선을 통해 연결되어 있다는 보장이 없기때문에 dfs()만으로는 모든 정점을 순서대로 발견한다는 목적에 부합하진 않는다.

그러므로 전체가 연결되어 있는 부분을 확인하기 위해서 dfs를 사용하는 경우도 많다.

## 깊이 우선 탐색의 시간 복잡도

깊이 우선 탐색 시간 복잡도는 어떤 그래프 표현방식을 따라하느냐에 따라 달라지는데 위의 코드에 따르면 인접리스트를 사용해 표현하였으므로 V번 호출이 된다. dfs한번 수행시간은 모든 인접 간선을 검사하는 for문에 의해 지배되는데 모든 정점에 대해 dfs를 수행하고 나면 모든 간선을 정확히 한 번 혹은 두 번 확인함을 알 수 있다.

## 깊이 우선 탐색을 사용하는 예제들

1. 두 정점이 서로 연결 되어 있는가를 확인

이 방법은 그래프 상의 두 정점 사이를 잇느 경로가 있는지 없는지를 확인할 수 있다. 그 방법은 어떤 정점 u에 대해 dfs를 수행하면 u에서부터 간선들을 통해 갈 수 있는 모든 정점을 다 방문하게되는데 그럴때 dfs를 수행하고 visited를 참조하게 되면 u로부터 해당 정점으로 갈 수 있는지 없는지를 판단 할 수있다.

2. 연결된 부분집합의 개수 

무향 그래프가 간선으로 서로 연결되지 않은 몇 개의 조각을 ㅗ쪼개져 있는 경우, 각 연결된 장점들의 부분집합을 컴포넌트 혹은 요소라고 부른다. 주어진 그래프가 몇 개의 컴포넌트로 구성되어 있는지 파악하는 것은 아주 기초적인 그래프 문제인다. 이것도 깊이 우선탐색으로 쉽게구할 수 있다. dfs함수는 시작한 정점에서 갈 수 있는 모든 정점들을 방문하기 때문에 한 점에서 dfs를 호출하고 나면 같은컴포넌트에 속한 점은 모조리 방문하게 된다. 따라서 dfsAll에서 dfs를 호출하는 횟수를 세개된다면 그래프가 몇개의 컴포넌트로 구성되어 있는지를 알 수 있다.

3. 위상 정렬

위상 정렬은 실생활에서 자주 등장하는 문제로 깊이 우선 탐색으로 풀 수 있는 가장 유명한 문제들 중 하나이다. 위상 정렬은 의존성이 있는 작업들이 주어질 때 이들을 어떤 순서로 진행해야 하는지 계산해준다. 이 작업은 아무 순서로나 진행 할 수없을때 사용되는데 요리를 하기 위해서 거쳐야 하는 작업들을 스스로 나타내는 형식이다.