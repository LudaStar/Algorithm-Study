## 이진 검색 트리

이진 검색 트리에서 중요한 부분은 이진 트리이다.
이진 트리란 루트에 총 두개의 노드 left,right만을 가지는 트리를 뜻 한다.
따라서 이진트리는 트리와 달리 배열이 아닌 두 개의 객체로 데이터를 저장한다.

이진 탐색트리는 N개의 원소 중에서 원하는 값을 찾는데, 매번 후보의 수를 절반씩 줄여갈 수 있다면 O(lgN) 시간에 그 값을 찾을 수 있다.
각 노드의 왼쪽 서브 트리에는 해당 노드의 원소보다 작은 원소를 가진 노드들이, 오른쪽 서브트리에는 보다 큰 원소를 가진 노드들이 들어간다.

이진 검색 트리를 중위 순회하면 크기 순서로 정렬된 원소의 목록을 얻울 수 있다. 현재 노드가 가진 원소보다 작은 원소들은 모두 왼쪽 서브트리에 있고, 그보다 큰 원소들은 모두 오른쪽 서브트리에 있기 때문이다.
트리를 중위 순회하면 정렬된 결과를 얻을 수 있다는 말은 집합에 포함된 최대 원소나 최소 원소를 쉽게 얻을 수 있다는 뜻이기도 하다. 중위 순회에서 가장 일찍 출력되는 노드는 루트에서 더이상 내려갈 수 없을 때까지 왼쪽 연결로 쭉 내려가서 만나는 노드이다. 따라서 이 노드가 최소 원소를 갖고, 반대로 오른쪽 연결을 따라 쭉 내려갔을 때 만나는 노드가 최대 원소를 갖게 된다.

이진 탐색 트리는 아주 간단하게 특정 원소가 존재하는지 확인할 수 있다. 예를 들어 x라는 값이 있으면 루트가 x보다 작은지 큰지를 판단 한 후 크다면 오른쪽, 작다면 왼쪽으로 내려가다보면 x의 값을 얻을 수 있다.

이진 탐색 트리의 가장 큰 특징은 선형적이지 않다는 부분에 있다. 원소를 내가 택한 위치에 넣기 위해서는 배열의 특정 부분을 찾고 각각의 원소들을 뒤로 한칸씩 밀어야 된다는 점에 있다. 하지만 트리에서는 선형적이지 않은 구조덕에 값을 넣는다고해서 특정 원소가 밀리거나 위치를 변경 시키지 않는다.
하지만 이런 이진탐색트리에서도 힘든 연산이 있는데 그것은 바로 특정 원소를 삭제하는데에 있다. 이진 트리의 원소를 삭제하게 되면 하위에 있는 서브 노드들의 구조가 망가지기 때문에 쉽사리 삭제하기가 어렵다. 하지만 이 또한 구현은 가능하다. 여러가지 방법이 있지만 가장 간단한 방법으로는 합치기 연산이란 것이 있다.

노드 T를 지울것이라 생각하면 T의 두 서브트리를 합친 새로운 트리를 만든 뒤 이 트리를 t를 루트로 하는 서브트리와 바꿔치기 하는 방법이다.
합치기 연산자체는 구현하기 어렵지 않다. 두 트리 A와 B를 합치려고 하는데, A의 최대 원소가 B의 최소 원소보다 더 작다고 합시다. 원래 A와 B는 한 노드의 t의 왼쪽/오른쪽 서브트리였으므로 이 성질은 자연스레 성립합니다. 이제 A의 루트 a가 합쳐진 트리의 루트가 되도록 두 트리를 합치면 된다.

## 너드인가, 너드가 아닌가? 

대 성황이었던 지난 알고스팟 연간 모의고사 이후 프로그래밍 대회의 열기는 날로 뜨거워져 올해는 10만명이 넘는 사람들이 참가 신청을 할 것으로 예상되고 있습니다. 그러나 채점관을 할 자원 봉사자는 예년과 똑같이 5명뿐이라, 이 사람들을 대회에 다 참가시킬 수는 없습니다. 따라서 올해에도 참가 신청을 한 사람 중 진정한 프로그래밍 너드들만을 대회에 참가할 수 있도록 받아 주기로 했습니다.

종만의 새로운 이론에 따르면, 어떤 사람의 너드 지수는 다음 두 가지 값에 의해 결정됩니다.

알고스팟 온라인 채점 시스템에서 푼 문제의 수 p

밤 새면서 지금까지 끓여먹은 라면 그릇 수 q

이 이론에 따르면 어떤 참가 신청자 a 의 문제 수 pa 와 그릇 수 qa 를 다른 참가 신청자 b 의 문제 수 pb 와 그릇 수 qb 에 각각 비교했을 때, pa < pb, qa < qb 라면 참가 신청자 a 는 너드일 가능성이 없습니다. 조직위는 너드일 가능성이 있는 사람들만을 대회에 받아주기로 했습니다.

한 사람의 참가 가능 여부는 다른 사람들에 의해 결정되기 때문에, 대회에 참가할 수 있는 사람의 수는 새로운 사람이 참가 신청을 할 때마다 계속 바뀝니다. 예를 들어 다음과 같은 4명의 사람들이 순서대로 참가 신청을 했다고 합시다.

참가자종만재훈효승광규

문제 수

72

57

74

64

라면 그릇 수

50

67

55

60

종만과 재훈이 순서대로 대회 참가 신청을 하면 대회에 참가할 수 있는 사람의 수는 각각 1, 2 로 늘어나지만, 효승이는 문제 수도 라면 그릇 수도 종만보다 많으므로 효승이 참가 신청을 한 시점에서 종만은 더 이상 대회에 참가할 수 없습니다. 따라서 이 네 명이 참가 신청을 할 때마다 참가 가능자의 수는 1, 2, 2, 3으로 변합니다.

이렇게 각 사람이 참가 신청을 할 때마다 대회에 참가할 수 있는 사람들의 수가 어떻게 변하는지 계산하는 프로그램을 작성하세요.

## 시간 및 메모리 제한

프로그램은 2초 안에 실행되어야 하며 64MB 이하의 메모리를 사용해하 합니다.

## 입력

입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 참가 신청한 사람들의 수 N (1 <= N <= 50000) 이 주어집니다. 그 후 N 줄에 각 2개의 정수로 각 사람의 문제 수 pi 와 라면 그릇 수 qi 가 참가 신청한 순서대로 주어집니다 (0 <= pi,qi <= 100000) . 두 사람의 문제 수나 라면 그릇 수가 같은 경우는 없다고 가정해도 좋습니다.
입력의 양이 많으므로 가능한 빠른 입력 함수를 사용하는 것이 좋습니다.

## 출력

각 사람이 참가 신청을 할 때마다 대회 참가 자격이 되는 사람의 수를 계산한 뒤, 각 테스트 케이스마다 그 합을 출력합니다.

## 예제 입력

	2
	4
	72 50
	57 67
	74 55
	64 60
	5
	1 5
	2 4
	3 3
	4 2
	5 1

## 문제 접근 방법

이 문제는 두개의 점끼리의 상관 관계가 있는 지를 파악 하면된다. 이 문제를 트리로 가져올 수 있는데 그 방법은 두개의 점에서 서로의 x,y좌표의 크기를 비교해 두 점이 서로 포함되는지 포함되지 않는 지를 파악한 후 확인한다.
만약 그런 점이 있다면 새 점은 무시하고, 그런 점이 없다면 이제 기존 점들 중 새 점이 지배하는 점들을 지워 버리면 된다.
이 때 지배 당하는 점은 자식 노드로 생각하고 지배하는 점은 부모 노드로 생각하면 편할 수 있다. 그렇게 된다면 이진 트리를 구성해 문제를 해결 해 나가면 구현이 가능하다.


## 코드

```
bool isDominated(int x, int y) {
	//x보다 오른족에 있는 점 중 가장 왼쪽에 있는 점을 찾는다.
	map<int, int>::iterator it = coord.lower_bound(x);
	//그런 점이 없으면 (x,y)는 지배당하지 않는다.
	if (it == coord.end()) return false;
	//이 점은 x보다 오른쪽에 잇는 점 중 가장 위에 있는 점이므로
	//(x,y)가 어느 점에 지배되려면 이 점에도 지배되어야 한다.
	return y < it->second;
}
```
위의 코드를 확인 했을 때  이진 탐색 트리로 구현된 map을 이용한 것을 확인 할 수 있다. map을 이용해  각 점의 정보를 저장하고 lower_bound는 트리에 포함된 x이상의 키 중 가장 작은 값을 돌려주므로 우리가 풀려는 문제에 사용할 수 있어 사용했다.
다음으로 우리가 구현해야 할 연산은 점들의 정보가 저장된 트리에서 새로운 점 q보다 작은 값은 모두 지우는 것이다.
우선 q의 바로 왼쪽에 있는 점에서부터 시작해 왼쪽으로 움직이면서 지배되는 점들을 지워간다. q에 지배당하지 않는 점이 등장하면 곧장 종료가 된다.

```
void removeDominate(int x, int y) {
	map<int, int>::iterator it = coord.lower_bound(x);
	//(x,y)보다 왼쪽에 있는 점이 없다.
	if (it == coord.begin()) return;
	--it;
	while (true)
	{
		//(x,y)바로 왼쪽에 오는 점을 찾는다
		//it가 표시하는 점이 (x,y)에 지배되지 않는다면 곧장 종료
		if (it->second > y) break;
		// 이전 점이 더 없으므로 it만 지우고 종료한다
		if (it == coord.begin()) {
			coord.erase(it);
			break;
		}
		else
		{
			map<int, int>::iterator jt = it;
			--jt;
			coord.erase(it);
			it = jt;
		}
	}
}

// 새 점(x,y)가 추가되었을 때 coord를 갱신하고,
// 다른 점에 지배당하지 않는 점들의 개수를 반환한다.
int registered(int x, int y) {
	//(x,y)가 이미 지배당하는 경우에는 그냥 (x,y)를 버린다.
	if (isDominated(x, y)) return coord.size();
	// 기존에 있던 점 중 (x,y)에 집당하는 점들을 지운다.
	removeDominate(x, y);
	coord[x] = y;
	return coord.size();
}
```

q에 포함되는 점들을 삭제하는 함수 입니다.
registered함수를 살펴보면 x,y를 버릴지 말지를 선택하는 isDominated의 상황에 따라 removedominated를 통해 값을 지울지 말지를 선택한다.

