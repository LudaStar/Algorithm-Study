# Map(Associate container)

Map은 각 노드가 key와 value값으로 이루어진 트리다. 가장 중요한점은 **중복을 허용하지 않는다** 이다.
따라서 map은 first, second가 존재하는 pair로 존재하는 컨테이너이다.

## Map의 구조

map은 트리로 만들어져있는 Red-Black tree입니다. 여기서 Red-Black tree는 다른 부분에서 정리를 해서 올리겠다.

## Map의 가장 좋은 활용방안

Map은 대체로 많은 자료를 정렬하여 저장하고 있을때 빠른 검색기반 알고리즘으로 사용할 수 있다. 또한 정해진 규칙에 따라서 자료를 삽입, 삭제를 해야 하기 때문에 삽입과 삭제가 간단하지 않으며 구현하기도 매우 복잡한 형태이다.

1. 정렬을 해야한다.
2. 많은 자료를 저장하고, 검색이 빨라야한다
3. 빈번한 삽입 및 삭제가 일어나지 않는다.

근데 map은 key값을 기준으로 자동으로 오름차순으로 정렬을하는 컨테이너 이므로 1번은 굳이 생각하지 않아도 된다.

### Map의 사용 방법
```
#include<map>

map<"data-type","data-type"> 변수
```

위와 같이 사용할 수 있는데 다른 STL함수와 같은 include를 사용해 map의 연산자 및 멤버함수를 사용할 수 있다.

첫 번째 데이터 타입은 key값으로 두 번째 데이터 타입을 가리키는 이름이라고 보면 된다. 두 번째 데이터 타입은 value값으로 key값의 data 값을 실질적으로 나타내는 겂이다.

또한 위에서 말했다시피 map은 자동 정렬을 해주기 때문에 기본 자료형이 아닌 유저 정의형(class/struct)는 새롭게 정렬 방식을 제공해야 한다.

만약 유저 정의형 정렬 방식을 사용하고 싶으면 사용방법은 간단하다

amp <"data-type","data-type", 비교함수>

비교함수 부분에 본인의 정의형 자료형을 정렬하는 방식을 구현해 넣으면된다. 

만약 내림차순으로 하고싶다면 STL에 존재하는 탬플릿, *greater* 를 넣어주면 내림차순으로 구현할 수 있다.

## map의 주요 멤버 함수들

* m.begin()
	* 첫 번째 원소의 랜덤 접근반복자를 반환

* m.clear()
	* 저장하고 있는 모든 원소를 삭제

* m.empty()
	* 저장하고 있는 요소가 존재하는지 여부를 판별(존재 = false, 비존재 = true)

* m.end()
	* 마지막 원소 다음으 반복자를 반환

* m.erase(key)
	* key 위치의 원소나 지정 범위의 원소들을 삭제
	* 범위 지정은 m.erase(key1,key2)로 지정할 수 있는데 이때 key1~key2사이의 key값들은 전부 제거된다.

* m.find(key)
	*key와 연관된 요소의 반복자 반환

* m.insert()
	* 여기엔 방법이 여러가지가 있다.
	1. 무식하게 때려 넣기 : m.insert("너",123)
	2. pair(STL) 사용해서 넣기 : m.insert(pair("너",2));
	3. 지정 반복자 구간에 있는 것들을 추가 : m1과 m2가 있을 때 m1(m2.begin(),m2.end());
	
	* 이러한 방식들로 데이터 값을 추가할 수 있다.

* m.lower_bound(key)
	*지정한 key의 요소를 가지고 있다면 해당 위치의 반복자를 반환

* m[i]
	* i의 위치의 요소에 원소 추가 및 접근 가능

* m.rbegin()
	* 역방향 첫 번째의 원소의 반복자를 반환

* m.rend()
	* 역방향으로 마지막 원소의 다음 반복자를 반환

* m.size()
	* 원소의 갯수를 반환

* m.upper_bound(key)
	* 지정한 키의 요소를 가지고 있다면 해당 위치 다음위치의 반복자를 반환

### MAP의 방법
1.
	map의 추가방법에는 insert를 사용하는데 특이한 방법인 반복자를 이용해서 추가를 하는 방법이 있다.

	방법은 다음과 같다

	map2.insert(map1.begin(), map1.end())

	이렇게 되면 map1의 반복자 구간에 있는 모든 요소를 map2에 추가를 할 수 있다.
	map의 특이점이 하나가 있는데 그것은 바로 같은 key값을 추가할 수 없습니다.
	map은 단일로 존재하는 key값을 정렬해놓은 값이므로 같은 값을 넣을 수 없다.

	다른 방법으로는 operator[]를 사용하여 추가하는 방법인데 
	배열과 마찬가지로 
	
	map1[10] = 80 이다. key값은 10이고 value값은 80이 된다.

2.
	반복자 사용방법인데 vector나 다른 container와 사용법은 크게 다르지 않다.
	begin,end,rbegin,rend를 사용해서 반복할 위치를 정하거나 사용할 수 있다.

3.
	검색하는 방법은 항상 key 값으로 한다.
	map에서  key의 값을 찾아서 나타내면 value값을 반환한다.

4.
	삭제의 방법은 erase와 clear을 사용하는데  erase는 부분의 값을 삭제하는 방식으로 clear는 전체의 값을 삭제하는 방식을 사용한다.

	특히나 erase는 구간반복 즉 begin,end,rbegin,rend을 사용해 구간을 지울 수도 있다.

	마찬가지로 key값을 찾으면 value값이 없어지고 한다.

	clear는 전체의 값을 없앨때 유용하다.