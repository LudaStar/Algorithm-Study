# Map(Associate container)

Map은 각 노드가 key와 value값으로 이루어진 트리다. 가장 중요한점은 **중복을 허용하지 않는다** 이다.
따라서 map은 first, second가 존재하는 pair로 존재하는 컨테이너이다.

## Map의 구조

map은 트리로 만들어져있는 Red-Black tree입니다. 여기서 Red-Black tree는 다른 부분에서 정리를 해서 올리겠다.

## Map의 가장 좋은 활용방안

Map은 대체로 많은 자료를 정렬하여 저장하고 있을때 빠른 검색기반 알고리즘으로 사용할 수 있다. 또한 정해진 규칙에 따라서 자료를 삽입, 삭제를 해야 하기 때문에 삽입과 삭제가 간단하지 않으며 구현하기도 매우 복잡한 형태이다.

1. 정렬을 해야한다.
2. 많은 자료를 저장하고, 검색이 빨라야한다
3. 빈번한 삽입 및 삭제가 일어나지 않는다.

근데 map은 key값을 기준으로 자동으로 오름차순으로 정렬을하는 컨테이너 이므로 1번은 굳이 생각하지 않아도 된다.

### Map의 사용 방법
```
#include<map>

map<"data-type","data-type"> 변수
```

위와 같이 사용할 수 있는데 다른 STL함수와 같은 include를 사용해 map의 연산자 및 멤버함수를 사용할 수 있다.

첫 번째 데이터 타입은 key값으로 두 번째 데이터 타입을 가리키는 이름이라고 보면 된다. 두 번째 데이터 타입은 value값으로 key값의 data 값을 실질적으로 나타내는 겂이다.

또한 위에서 말했다시피 map은 자동 정렬을 해주기 때문에 기본 자료형이 아닌 유저 정의형(class/struct)는 새롭게 정렬 방식을 제공해야 한다.

만약 유저 정의형 정렬 방식을 사용하고 싶으면 사용방법은 간단하다

amp <"data-type","data-type", 비교함수>

비교함수 부분에 본인의 정의형 자료형을 정렬하는 방식을 구현해 넣으면된다. 

만약 내림차순으로 하고싶다면 STL에 존재하는 탬플릿, *greater* 를 넣어주면 내림차순으로 구현할 수 있다.

## map의 주요 멤버 함수들

* m.begin()
	* 첫 번째 원소의 랜덤 접근반복자를 반환

* m.clear()
	* 저장하고 있는 모든 원소를 삭제

* m.empty()
	* 저장하고 있는 요소가 존재하는지 여부를 판별(존재 = false, 비존재 = true)

* m.end()
	* 마지막 원소 다음으 반복자를 반환

* m.erase()
	* 특정위치의 원소나 지정 범위의 원소들을 삭제

* 

