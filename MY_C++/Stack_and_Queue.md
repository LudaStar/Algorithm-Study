## 조세푸스문제

조세푸스는 로마와의 전재에 패해 N-1명의 동료 병사들과 함께 출구가 없는 동굴에 포위당했다고 합니다. 동료 병사들은 자결을 선택했고 포위당한 N명의 사람들이 모두 원형으로 둘러선 뒤 순서대로 자살하기로 했습니다. 한사람이 자살하면 다음에는 그사람으로부터 시계방향으로 K번째 살아 잇는 사람이 자살하는 것입니다. 이 때 마지막 두명중 하나의 병사가 되기위해서는 조세푸스는 첫 번째 병사로부터 몇 자리 떨어진 곳에 있어야 하는가?

### 입력
입력의 첫 번째 줄에는 테스트 케이스의 갯수 C(C<50)가 주어진다. 각 테스트 케이스는 두 개의 정수 N,K로 주어진다

### 출력

각 테스트 케이스에 두 개의 정수로 마지막 살아남는 두 사람의 번호를 오를차순으로 정렬한다.

### 예제 입력

	2
	6 3
	48 3

### 예제 출력

	3 5
	11 26

### 문제 접근

이 문제는 앞서 list로 풀었지만 queue를 이용해서 더욱 간단하게 풀 수 있다.
매우 간단하게 생각하면 queue는 선입선출의 개념으로 먼저 들어간 값이 항상 최우선값을 나타낸다. 또한 앞과 뒤 모두에서 값을 뺄수 있으므로 조세푸스 문제에 적용 할 수 있다.

코드는 다음과 같다.

### 코드

```
void josephous(int n, int k) {
	if (n == 0) return;
	queue<int> survivor;
	for (int i = 1; i <= n; ++i) {
		survivor.push(i);
	}
	int p;
	while (1)
	{
		if (survivor.size() == 2)
		{
			cout << survivor.front() << " " << survivor.back() << endl;
			break;
		}
		survivor.pop();
		for (int i = 0; i < k - 1; ++i) {
			p = survivor.front();
			survivor.push(p);
			survivor.pop();
		}
	}
}
```

초반 구현부분은 list와 비슷하다 한가지 달라진 점이 있다면 사람이 k번째의 사람을 선택하는 방식이다.
lIst의 구현에서는 k번째 사람을 가르킬때 포인터 자체 즉 iteration 변수를 사용해서 포인터의 위치를 바꿨다. 이때 if문이 하나 더들어가게 되는데 queue를 사용하면 좀더 간결하게 표현이 가능하다.
그건 맨앞의 병사를 죽인후 병사들을 움직이는 것이다. 즉 k라는 위치의 사람을 맨 앞으로 보내서 제거하는 방식이다.
코드가 한눈에 보기 편하고 깔끔하게 변한것을 확인 할 수 있다.

### 울타리 재활용

## 울타리 잘라내기 

### 문제
너비가 같은 N개의 나무 판자를 붙여 세운 울타리가 있습니다. 시간이 지남에 따라 판자들이 부러지거나 망가져 높이가 다 달라진 관계로 울타리를 통째로 교체하기로 했습니다. 이 때 버리는 울타리의 일부를 직사각형으로 잘라내 재활용하고 싶습니다. 그림 (b)는 (a)의 울타리에서 잘라낼 수 있는 많은 직사각형 중 가장 넓은 직사각형을 보여줍니다. 울타리를 구성하는 각 판자의 높이가 주어질 때, 잘라낼 수 있는 직사각형의 최대 크기를 계산하는 프로그램을 작성하세요. 단 (c)처럼 직사각형을 비스듬히 잘라낼 수는 없습니다.

판자의 너비는 모두 1이라고 가정합니다.

<img src = "https://algospot.com/media/judge-attachments/506874700c7251881727ee4e70a1d502/fence.png">

### 입력

첫 줄에 테스트 케이스의 개수 C (C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 판자의 수 N (1≤N≤20000)이 주어집니다. 그 다음 줄에는 N개의 정수로 왼쪽부터 각 판자의 높이가 순서대로 주어집니다. 높이는 모두 10,000 이하의 음이 아닌 정수입니다.
	3
	7
	7 1 5 9 6 7 3
	7
	1 4 4 4 4 1 1
	4
	1 8 2 2


### 출력

각 테스트 케이스당 정수 하나를 한 줄에 출력합니다. 이 정수는 주어진 울타리에서 잘라낼 수 있는 최대 직사각형의 크기를 나타내야 합니다.
	20
	16
	8

### 문제 접근

여기서는 stack을 응용해서 푼 문제인데 생각해내면 간단하게 코드로구현이 가능하지만 생각하기가 조금 어려운 부분이었다.

여기서 생각해야 될것은
1, 첫번째 울타리가 두번째 울타리 보다 큰것인가?
2. 만약 크다면 최대 울타리 크기는 얼마인가?

이것을 생각하게 된다면 알고리즘을 설계하면 된다.

먼저 울타리를 확인해보면 내가 만약 i번째의 울타리를 골랐는데 왼쪽에 이미 골랏던 울타리가 자신의 크기보다 작다면 거기까지 계산된 값을 최대크기라 생각하고 저장하는 것이다. 그리고 나선 그 왼쪽의 크기가 같거나 큰 것들의 값들을 계산한 값을 저장해두고 MAX함수를 사용해 최대값을 구하는 식이다.

예를 들어보자. 첫 번째 울타리의 높이가 3이라고 하고 두번째 높이가 2, 세번째 높이가 5라고 하자.

그러면 1번째 울타리를 선택했을때 왼쪽의 높이가 없으므로 가장 큰 넓이가 된다.

다음으로 2번째 울타리를 선택했을 때 왼쪽의 높이가 3으로 2보다 크므로 왼쪽의 울타리는 남겨두고 두번째 울타리까지 남겨둔다.

3번째 울타리를 선택하게되면 왼쪽의 높이가 2로 최대의 크기가 될 수 없으므로 여기서 최대 넓이를 계산하는 방법이다.

자 예를 토대로 코드를 작성해보자

### 코드

```
vector<int> h;

int solveStack() {
	stack<int> remaining;
	h.push_back(0);
	int ret = 0;
	for (int i = 0; i < h.size(); ++i) {
		while (!remaining.empty() && h[remaining.top()] >= h[i]) {
			int j = remaining.top();
			remaining.pop();
			int width = -1;
			if (remaining.empty())
				width = 1;
			else
				width = (i - remaining.top() - 1);
			ret = max(ret, h[j] * width);
		}
		remaining.push(i);
	}
	return ret;
}
```

여기서 보면 while부분이 제일 중요하다. 먼저 남겨둘 울타리를 저장하는 remaining 변수를 확인하고 비어있다면 다시 스텍에 값을 넣는 방식으로 진행된다. 이때 이후 판자가 현재의 크기보다 크다면 다시 스텍을 쌓는 방법을 반복한다.
보면 아하 하고 알 수있지만 다시 돌아보는 시간도 중요한것 같다.