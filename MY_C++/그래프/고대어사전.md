# 고대어 사전

아마추어 고고학자인 일리노이 존스는 시카고 근교에서 고대 문명의 흔적을 찾아냈습니다. 그 흔적 중에는 이 언어의 사전도 포함되어 있었는데, 이 사전에 포함된 단어들은 모두 영어의 소문자 알파벳으로 구성되어 있었지만 사전에 포함된 단어의 순서들이 영어와 서로 달랐습니다. 발굴팀은 단어들이 사전 순이 아닌 다른 순서대로 정렬되어 있는지, 아니면 알파벳들의 순서가 영어와 서로 다른 것인지를 알고 싶어합니다.

일리노이 존스는 이 언어에서는 알파벳들의 순서가 영어와 서로 다를 뿐, 사전의 단어들은 사전 순서대로 배치되어 있다는 가설을 세웠습니다. 이 가설이 사실이라고 가정하고, 단어의 목록으로부터 알파벳의 순서를 찾아내려고 합니다.

예를 들어 다섯 개의 단어 gg, kia, lotte, lg, hanhwa 가 사전에 순서대로 적혀 있다고 합시다. gg가 kia보다 앞에 오려면 이 언어에서는 g가 k보다 앞에 와야 합니다. 같은 원리로 k는 l앞에, l은 h앞에 와야 한다는 것을 알 수 있지요. lotte 가 lg 보다 앞에 오려면 o가 g 보다 앞에 와야 한다는 것도 알 수 있습니다. 이들을 종합하면 다섯 개의 알파벳 o, g, k, l, h 의 상대적 순서를 알게 됩니다.

사전에 포함된 단어들의 목록이 순서대로 주어질 때 이 언어에서 알파벳의 순서를 계산하는 프로그램을 작성하세요.

## 입력 

입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 사전에 포함된 단어의 수 N (1 <= N <= 1000) 이 주어집니다. 그 후 N 줄에 하나씩 사전에 포함된 단어가 순서대로 주어집니다. 각 단어는 알파벳 소문자로 구성되어 있으며, 길이는 1 이상 20 이하입니다. 중복으로 출현하는 단어는 없습니다.

## 출력

각 테스트 케이스마다 한 줄을 출력합니다. 만약 알파벳들의 순서에 모순이 있다면 "INVALID HYPOTHESIS"를 출력하고, 모순이 없다면 26개의 소문자로 알파벳들의 순서를 출력합니다. 만약 가능한 순서가 여러 개 있다면 아무 것이나 출력해도 좋습니다.

## 예제 입력

	3
	3
	ba
	aa
	ab
	5
	gg
	kia
	lotte
	lg
	hanhwa
	6
	dictionary
	english
	is
	ordered
	ordinary
	this

## 예제 출력

	INVALID HYPOTHESIS
	ogklhabcdefijmnpqrstuvwxyz
	abcdefghijklmnopqrstuvwxyz

## 문제 풀이

이 문제를 풀기 위해서는 그래프를 모델링 해야지 풀어 나가기 편하다. 먼저 a와 b를 비교한다고 했을 때 a가 사전에 먼저 출현했다고 하자 그러면 첫글자끼리 비교하면서 처음으로 다른 글자를 찾는다. 그러면 a의 해당 글자는 알파벳 상에서 b의 해당 글자보다 앞에 와야한다.

이와 같은 순서들을 인접그래프로 표현하고 각 알파벳을 정점으로 만들면 단순한 구조의 그래프가 만들어진다. 
이를 위상정렬을 하게 된다면 우리가 원하는 알파벳의 순서를 알 수가 있다.

아래 코드에서는 그래프를 각 알파벳 소문자를 표현하는 26개의 정점을 만들고 글자 i가 j보다 먼저 와야 할 경우 간선 (i,j)를 얻는다.

```

//알파벳의 각 글자에 대한 인접 행렬 표현
//간선 (i,j)는 알파벳 i가 j보다 앞에 와야 함을 의미한다.
vector<vector<int>> adj;
// 주어진 단어들로부터 알파벳 간의 선후관계 그랲를 생성한다.

void makeGraph(const vector<string>& words) {
	adj = vector<vector<int>>(26, vector<int>(26, 0));
	for (int j = 1; j < words.size(); ++j) {
		int i = j - 1, len = min(words[i].size(), words[j].size());
		//word[i]가 word[j] 앞에 오는 ㅇ이류를 찾는다.
		for (int k = 0; k < len; ++k) {
			int a = words[i][k] - 'a';
			int b = words[j][k] - 'a';
			adj[a][b] = 1;
			break;
		}
	}
}

```
이 그래프의 가장 유의해야 하는 경우는 앞에 있는 단어가 뒤에 오는 단어의 접두사인 때 이다.
하지만 위와 같이 코드를 작성하면 예외처리가 필요없다.

## 인접 단어 검사하기

이 함수에서 눈여겨 봐야 할 것은 모든 단어 쌍을 검사하는 것이 아닌 사전상에서 인접한 단어들만을 검사한다는 것이다. 다시 말해 사전에 세단어 a,b,c가 등장한다면, a,c는 검사하지 않고 a,b와 b,c만 검사한다는 것인데 이렇게만 해도 위상정렬에 필요한 정보를 모두 얻을 수 있다. 

증명은 매우 간단하다. 예를 들어 a,b,c라는 단어가 있을 때 a가 b보다 빠르고 b보다 c가 빠르다면 당연하게도 순서는 c,b,a가 된다 따라서 인접한 단어들만 검사하더라도 그래프는 위상 정렬 결과는 모든 단어 쌍을 검사했을 때와 같음을 알 수 있다.

## 위상 정렬의 구현

이와 같이 그래프를 생성하고 나면 남은것은 이 그래프에 사이클이 있는지 없는지를 확인하고 없다면 위상 정렬 결과를 반환하는 것이다. 그러나 이 문제에서는 어짜피 위상 정렬을 해야하기 때문에 직접 확인할 필요가 없다. 코드를 확인해 보자.

```

vector<int> seen, order;
void dfs(int here) {
	seen[here] = 1;
	for (int there = 0; there < adj.size(); ++there) {
		if (adj[here][there] && !seen[there])
			dfs(there);
	}
	order.push_back(here);
}

//adj에 주어진 그래프를 위상정렬 한 결과를 반환한다.
//그래프가 DAG가 아니라면 빈 벡터를 반환한다.
vector<int> topologicalSort() {
	int m = adj.size();
	seen = vector<int>(m, 0);
	order.clear();
	for (int i = 0; i < m; i++) if (!seen[i]) dfs(i);
	reverse(order.begin(), order.end());
	//만약 그래프가 DAG가 아니라면 정렬 결과에 역방향 간선이 있다.
	for (int i = 0; i < m; ++i)
		for (int j = i + 1; j < m; ++j)
			if (adj[order[j]][order[i]])
				return vector<int>();
		//없는 경우라면 깊이 우선 탐색에서 얻은 순서를 반환한다.
	return order;
} 

```

dfs의 함수에서 확인할 수 있듯이 모든 단어의 순서를 확인한다. 깊이 우선 탐색을 수행하면서 dfs가 종료하는 순서를 기록한 뒤 이 순서를 뒤집는다. 만약 사이클이 없다면 이 순서는 그래프의 위상정렬 결과가 될것이다.
이때 이 순서대로 정점들을 배열했을 때 오른쪽에서 왼쪽으로 가는 간선이 있는지 확인해서 그래프의 사이클 존재 여부를 알 수 있다.
