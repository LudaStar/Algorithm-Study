#깊이 우선 탐색과 간선의 분류

깊이 우선 탐색을 수행하면 그 과ㅏ정에서 그래프의 모든 간선을 한 번씩은 만나게 됩니다. 그 중 일부 간선은 처음 발견한 정점으로 연결되어 있어서 우리가 따라갈 테고, 나머지는 무시하게 될 거다. 하지만 이 간선들을 무시하지 않고 이들에 대한 정보를 수집하면 그래프의 구조에 대해 많은 것을 알 수 있다.

 어떤 글프를 깊이 우선 탐색 했을때, 탐색이 따라가는 간선들만 모아보면 트리 형태를 띄게 된다. 
그래프의 어느 부분에서 깊이 우선 탐색을 했을때 몇몇 그래프들은 선택한 정점을 루트로하는 트리의 형태를 띄는 것도 있다. 이러한 트리를 그래프의 깊이 우선 탐색 스패닝 트리 혹은 DFS 스패닝 트리 라고 부른다. 그래프의 DFS 스패닝 트리를 생성하고 나면 그래프의 모든 간선을 다음과 같이 네 가지 중 하나로 분류할 수 있다.

1. 트리의 간선은 스패닝 트리에 포함된 간선을 의미한다. 
2. 순방향 간선은 스패닝 트리의 선조에서 자손으로 연결되지ㅏㄴ 트리 간선이 아닌 간선을 말한다. 
3. 역방향 간선은 스패닝 트리의 자손에서 선조로 연결되는 간선을 말한다.
4. 이 세가지 분류를 제외한 나머지 간선들은 교차 간선이라고 부른다. 교차간선은 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선들을 의미한다. 

이 그래프의 간선은 항상  이렇게 분류하는 것은 아니다 깊이 우선 탐색이 어느 순서대로 정점을 방문하느냐에 따라 서로 다른 트리가 생성될 수 있고, 그에 따라 각 간선의 구분이 서로 달라질 수 있다.

## 무향 그래프의 간선 분류

무향 그래프의 간선은 어떻게 분류하냐면 무향 그래프의 모든 간선은 양방향으로 통행 가능하므로 무향 그래프에는 교차 간선이 있을 수 없다. 간선 (u,v)가 교차간선이기 위해서는 V가 먼저 방문된 후 u를 방문하지 않고 종료해야 하는데, 무향 그래프의 경우(u,v)를 이용해 V에서 u로 갈 수 있기 때문이다. 또한 무향 그래프에서 순방향 간선과 역방향 간선의 구분이 없다는 점도 유의해야 한다.

## 위상 정렬의 정당성 증명

간선의 분류는 그 자체가 유용하다기보다는 그래프의 알고리즘을 이해하고 증명하기 위한 도구로 유용하게 쓰입니다. 간선 분류의 사용 예로 28.1절에서 다뤘던 위상 정렬의 정당성 증명을 다시 해 보겠습니다. 우리의 위상 정렬 알고리즘은 dfs()의 종료 역순으로 정점을 배열하므로 dfs(u)가 dfs(v)보다 일찍 종료할 경우 u에서 v로 가는 간선이 ㄷ존재할 수 없다는 것만 증명하면 그 정당성을 보일 수 있다.

1. (u,v)가 트리 간선이라면 dfs(u)에서 dfs(v)를 호출했ㄷ는 말인데, 그러면 dfs(u)가 먼저 종료할 수 없다.
2. (u,v)가 역방향 간선이라면 v가 u의 선조이므로 v에서 u로 가는 경로가 있다는 뜻인데 여기에 (u,v)를 붙이면 사이클이 되므로 그래프가 DAG라는 가정에 모순이 생긴다.
3. (u,v)가 순방향 간선이라면 u가 v의 선조라는 뜻인데, 이때 dfs(u)가 먼저 종료하는 것은 불가능하다.
4. (u,v)가 교차 간선이라면 dfs(v)가 종료하고 나서 u를 방문했다는 뜻인데, 이것은 dfs(u)가 먼저 종료했다는 것과 모순입니다.

따라서 이와 같은 간선 (u,v)는 존재할 수 없고, 위상 정렬의 정당성은 증명됩니다.

## 간선을 구분하는 방법

가장 구분하기 쉬운 간선은 트리 간선이다. dfs(u)내에서 간선 (u,v)를 검사했을 때 v가 방문된 적이 없다면 이 간선을 따라가므로(u,v)는 트리 간선이 된다. 반면 v를 이미 방문한 후였다고 하면 이것만으로는 v가 u의 부모인지, 자손인지, 둘 다 아닌지 알 수 없다.
따라서 탐색 과정에서 각 정점을 방문한 적이 있는지 여부 외에 다른 정보를 저장해야 한다. 한가지 방법은 각 정점을 방문할 때 이 정점이 방문되었다는 사실 뿐만 아니라 , 이 정점이 몇번째로 발견되었는지도 동시에 기록하는 것이다. 탐색 과정에서 각 정점을 몇번째로 발견했는지를 배열 discorverd[]에 저장한다고 하자 이 정ㅂ를 이용해서 순방향과 역방향 그리고 교차 간선을 구분해 낼 수 있을까? 간선 (u,v)를 검사했는데 v가 이미 방문된 상태였다고 하면 이때 u와 v의 방문 순서를 이용해 (u,v)를 분류할 수 있을까?

1. (u,v)가 수낭향 간선이라면 v는 u의 자손이어야 한다. 따라서 v는 u보다 더 늦게 발견되어야 한다.
2. (u,v)가 역방향 간선이라면 v는 u의 선조여야 한다. 따라서 v는 u보다 일찍 발견되었어야 한다.
3. (u,v)가 교차 간선이라면 dfs(u)가 종료한 후 dfs(u)가 호출되어야 한다. ㄸ라서 v는 u보다 일찍 발견되어야 한다.

## 코드

```

//그래프의 인접 리스트 표현
vector<vector<int>> adj;
//discoverd[i] = i번 정점의 발견 순서
// finished[i] = dfs(i)가 종료했으면1, 아니면 0

vector<int> discorverd, finished;
//지금까지 발견한 정점의 수
int counter;

void dfs2(int here) {
	discorverd[here] = counter++;
	//모든 인접 정점을 순회하면서

	for (int i = 0; i < adj[here].size(); ++i) {
		int there = adj[here][i];
		cout << "(" << here << "," << there << ") is a";
		//아직 방문한 적이 없다면 방문한다.
		if (discorverd[there] == 1) {
			cout << "tree edge" << endl;
			dfs2(there);
		}
		//만약 there가 here보다 늦게 발견됐으면 there는 here의 후손이다.
		else if (discorverd[here] < discorverd[there])
		{
			cout << "forward edge" << endl;
		}
		else if (finished[there] == 0)
			cout << "back edge" << endl;
		else
			cout << "cross edge" << endl;
	}
	finished[here] = 1;
}
```
