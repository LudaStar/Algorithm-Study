# 절단점 찾기 알고리즘

깊이 우선 탐색을 이용해 풀 수 있는 좀더 본격적인 응용 문제 중 하나로 그래프의 절단점 찾는 문제가 있다. 어떤 무향 그래프의 절단점이란 이 점과 인접한 간선들ㅇ르 모두 지웠을 때 해당 컴포넌트가 두개 이상으로 나눠지는 정점을 말한다.

사실상 절단점을 찾는 문제는 현실 세계에서도 중요한 의미를 가진다. 어떤 네트워크를 표현한 그래프에 절단점이 있다면, 이 그래프는 해당 라우터가 고장날 경우 마비됀다.
철도망을 표현한 그래프에 절단점이 있다면, 해당 기차역이 폐쇄될 경우 전체 철도망이 마비된다.
 어떤 정점이 절단점인지 확인하는 간단한 방법은 해당 정점을 그래프에서 삭제한 뒤, 컴포넌트의 개수가 이전보다 늘어났는지를 확인하는 것이다. 컴포넌트의 개수를 세는 것은 깊이 우선 탐색으로 간단하게 할 수 있다. 탐색 과정에서 얻는 정보를 이용하면 한번의 깊이 우선 탐색만으로 그래프의 모든 절단점 여부를 확인할 수 있다.
임의의 정점에서부터 깊이 우선 탐색을 수행해 DFS 스패닝 트리를만든다고 가정하자. 이때 어떤 정점 u가 절단점인지를 아는 방법은 스패닝 트리에는 교차 간선이 없으므로, u와 연결된 정점들은 모두 u의 선조 아니면 자손이다. 이때 u의 자손들을 루트로 하는 서브트리들은 서로 연결되어 있지 않다. 이들을 연결하느 간선이 있다면 교차 간선인데, 무향 그래프에서는 교차 간선이 있을 수 없기 때문이다.
따라서 u가 지워졌을 때 그래프가 쪼개지지 않는 유일한 경우는 그림에 그려진 것처럼 u의 선조와 자손들이 전부 역방향 간선으로 연결되어 있을 때 뿐이다. 이것을 확인하는 간단한 방법은 dfs2()가 각 정점을 루트로 하는 서브트리에서 역 방향 간선을 통해 갈 수있는 정점의 최소 깊이를 반환하도록 하는 것이다. 만약 u의 자손들이 모두 역방향 간선을 통해 u의 선조로 올라갈 수 있다면 u는 절단점이 아니다.
그러면 u가 스패닝 트리의 루트라서 선조가 없다면 어떨까? u는 무조건 절단점이라고 생각하기 쉽지만, 간과하기 쉬운 예외가 있다. 바로 자손이 하나도 없거나 하나밖에없는 경우다. 이 경우 u가 없어져도 그래프는 쪼개지지 않는다. 따라서 u가 루트인 경우 둘 이상의 자손을 가질 때만 절단점이 된다.

아래의 코드는 이와 같은 과정을 거쳐 한 번의 깊이 우선 탐색으로 모든 절단점을 출력하는 함수의 구현을 보여준다.
이전 dfs2와 달리 아래의 함수는 finished 배열을 계산하지 않느것도 확인 할 수있었다.

## 코드

```
//그래프의 인접 리스트 표현

vector<vector<int>> adj;
//각 정점의 발견 순서 -1로 초기화

vector<int> discovered;
//각 정점이 절단점인지 여부를 저장한다. false로 초기화
vector<bool> isCuVertex;
int counter = 0;
//here를 루트로 하는 서브 트리에 있는 절단점들을 찾는다.
//반환 값은 해당 서브트리에서 역방향 간선으로 갈 수 있는 정점 중
// 가장 일찍 발견된 정점의 발견 시점, 처음 호출할 때는 isRoot=true로 둔다
int findCutVertex(int here, bool isRoot) {
	//발견 순서를 기록한다.
	discovered[here] = counter++;
	int ret = discovered[here];
	//루트인 경우 절단점 판정을 위해 자손 서브트리의 개수를 센다
	int children = 0;
	for (int i = 0; i < adj[here].size(); ++i) {
		int there = adj[here][i];
		if (discovered[there] == 1) {
			++children;
			//이 서브트리에서 갈 수 있는 가장 높은 정점의 번호
			int subtree = findCutVertex(there, false);
			//그 노드가 자기 자신 이하에 있다면 현재 위치는 절단점
			if (!isRoot && subtree >= discovered[here])
				isCuVertex[here] = true;

			ret = min(ret, subtree);
		}
		else
		{
			ret = min(ret, discovered[there]);
		}
	}
	//루트인 경우 절단점 판정은 서브트리의 개수로 한다
	if (isRoot) isCuVertex[here] = (children) >= 2;

}
```
무향 그래프에서 절단점을 포함하지 않는 서브 그래프를 이중 결합 컴포넌트 라고 부른다. 이중 결합 컴포넌트 내에서는 임의의 한 정점을 그래프에서  지우더라도 정점 간의 연결 관계가 유지된다.
이중 결합 컴포넌트 내에서는 임의의 한 정점을 그래프에서 지우더라도 정점 간의 연결 관계가 유지된다.

