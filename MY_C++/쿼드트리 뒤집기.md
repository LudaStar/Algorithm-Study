### 쿼드 트리 뒤집기
대량의 좌표 데이터를 메모리 안에 압축해 저장하기 위해 사용하는 여러 기법 중 쿼드 트리(quad tree)란 것이 있습니다. 주어진 공간을 항상 4개로 분할해 재귀적으로 표현하기 때문에 쿼드 트리라는 이름이 붙었는데, 이의 유명한 사용처 중 하나는 검은 색과 흰 색밖에 없는 흑백 그림을 압축해 표현하는 것입니다. 쿼드 트리는 2N × 2N 크기의 흑백 그림을 다음과 같은 과정을 거쳐 문자열로 압축합니다.

* 이 그림의 모든 픽셀이 검은 색일 경우 이 그림의 쿼드 트리 압축 결과는 그림의 크기에 관계없이 b가 됩니다.
* 이 그림의 모든 픽셀이 흰 색일 경우 이 그림의 쿼드 트리 압축 결과는 그림의 크기에 관계없이 w가 됩니다.
* 모든 픽셀이 같은 색이 아니라면, 쿼드 트리는 이 그림을 가로 세로로 각각 2등분해 4개의 조각으로 쪼갠 뒤 각각을 쿼드 트리 압축합니다. 이때 전체 그림의 압축 결과는 x(왼쪽 위 부분의 압축 결과)(오른쪽 위 부분의 압축 결과)(왼쪽 아래 부분의 압축 결과)(오른쪽 아래 부분의 압축 결과)가 됩니다. 예를 들어 그림 (a)의 왼쪽 위 4분면은 xwwwb로 압축됩니다.
* 그림 (a)와 그림 (b)는 16×16 크기의 예제 그림을 쿼드 트리가 어떻게 분할해 압축하는지를 보여줍니다. 이때 전체 그림의 압축 결과는 xxwww bxwxw bbbww xxxww bbbww wwbb가 됩니다.

쿼드 트리로 압축된 흑백 그림이 주어졌을 때, 이 그림을 상하로 뒤집은 그림 을 쿼드 트리 압축해서 출력하는 프로그램을 작성하세요.

<img src=https://algospot.com/media/judge-attachments/0cafdb9ffa8ace4fb8315949d25d2fb3/quadtree.png>

### 입력

첫 줄에 테스트 케이스의 개수 C (C≤50)가 주어집니다. 그 후 C줄에 하나씩 쿼드 트리로 압축한 그림이 주어집니다. 모든 문자열의 길이는 1,000 이하이며, 원본 그림의 크기는 220 × 220 을 넘지 않습니다.

### 출력

각 테스트 케이스당 한 줄에 주어진 그림을 상하로 뒤집은 결과를 쿼드 트리 압축해서 출력합니다.

### 예제 입력

	4
	w
	xbwwb
	xbwxwbbwb
	xxwwwbxwxwbbbwwxxxwwbbbwwwwbb

### 예제 출력

	w
	xwbbw
	xxbwwbbbw
	xxwbxwwxbbwwbwbxwbwwxwwwxbbwb


## 문제 접근 방식

쿼드 트리를 뒤집는 가장 간단한 방법은 압축된 문자열을 압축 해제한 후 이미지 전체를 뒤집은 후 다시 압축하는 방식
하지만 그렇게 된다면 시간도 오래걸리고 이미지가 커진다면 제 시간내에 할 수 없을 확률도 있음.
그렇다면 시도해볼 방법은 

* 큰 입력에도 동작하는 알고리즘 제작
* 작은 입력에서 동작하는 알고리즘을 만든 후 최적화

하지만 이렇게 작동을 하게 될 경우 시간이 오래 걸리게 된다.

그렇다면 문자 자체적으로 생각해 보기로 했다.

이 문제는 압축된 파일이 재귀적으로 구현되어있기 때문에 압축파일은 순서대로 왼쪽위부터 오른쪽 아래 순서로 만들어져 있을 것이다.
그렇다면 압축을 풀지 않고 순서대로 뒤집어서 사용을 하게된다면 압축도 풀지않고 짧은 시간내에 풀 수 있을 것이다.

### 문제 풀이 방식

위에서 말했다 시피 압축을 풀지않고 순서대로 뒤집는다면 압축을 풀 지않고 쿼드트리를 반전시킬 수 있다.

이미지를 생각해보면 1,2,3,4,로 되어있는 간단한 이미지가 있다.
|1|2|
|3|4|

여기서 이 숫자를 이미지로 생각하고 뒤집는다 생각하면

|3|4|
|1|2|
(숫자는 뒤집힌 형태로 생각하면 된다.)
가 만들어진다.

이걸 차례대로 뒤집게되면

왼쪽 위-> 오른쪽 위 -> 왼쪽 아래 -> 오른쪽 아래 순으로 뒤집게 되면 전체 이미지는 반전이미지를 획득 할 수 있다.

따라서 코드도 매우 간단해진다.

```
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

string reverse(string::iterator it) {
	char head = *it;
	++it;`
	if (head == 'b' || head == 'w')
		return string(1, head);
	string upperLeft = reverse(it);
	string upperRight = reverse(it);
	string lowerLeft = reverse(it);
	string lowerRight = reverse(it);

	return string("x") + lowerLeft + lowerRight + upperLeft + upperRight;

}
```
이처럼 복잡한 문제도 작은 부분부터 풀어가면 쉽게 동작이 가능하다.
트리 문제는 몇개로 나뉘냐에따라 한부분이 재귀함수로 구성되어 있는 것을 알게되었다.

시간 복잡도는 O(n)이므로 매우 빠른 것도 확인 할 수 있다.
