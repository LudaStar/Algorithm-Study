### 동적 계산법

동적 계산법이란 Dynamic progaming으로써 흔히 생각하는 동적 즉, 움직이는 프로그래밍이 아니다.
동적 계산법이란것은 완전탐색기법에서 반복계산된 부분을 제거하는 특별한 경우에만 동작시키는 Programing 기법을 말한다.

어떤 가상의 문제가 있다고 가정해보자. 이 때 중복되는 부분이 하나 이상이 있는 프로그램에서 미리 계산해둔 값을 사용함으로써 중복적으로 함수를 호출하지 않는 방법을 얘기한다.

<img src = "https://t1.daumcdn.net/cfile/tistory/225D9D4D5936338C27">

위의 그림은 Fibonachi 수열로 유명한 부분이다. 이때 파란색으로 칠해져 있는 부분은 한번 이상 계산된 부분으로 반복적으로 여러번 사용되는 것을 볼수 있다.
피보나치 수열에서 보면 Fib(2)가 여러번 반복되며 오버헤드가 증가함으로 결국 비효율적인 코드가 된다.(여기서 오버헤드란? - 어떤 처리를 하기위해 들어가는 간접적인 처리시간, 메모리 등을 말한다.)

이때 미리 만들어놓은 배열안에 FIb(2)라는 계산식을 넣게 된다면 우리는 이 계산을 더욱 단순하게 할 수 있다. 

피보나치 수열의 동적 계산법은 많이 유명하니 인터넷을 보고 확인하면서 한번 구현해보았다.

```
int fib(int n)
{
	fibonachi[0] = fibonachi[1] = 1;
	for (int i = 2; i <= n; i++) {
		fibonachi[i] = fibonachi[n - 1] + fibonachi[n - 2];
	}
	return fibonachi[n];
}
```

다른 예를 들어 보겠다.

이번에는 또다른 유명한 이항계산 수식이다. 이부분은 완전탐색기법과 동적 계산법을 같이 사용하여  구현해 보았다.

```
int bino(int n, int r) {
	if (r == 0 || n == r) return 1;
	return bino(n - 1, r - 1) + bino(n - 1, r);
}

int cache[30][30];
int bino2(int n, int r) {
	if (r == 0 || n == r) return 1;
	if (cache[n][r] != -1)
		return cache[n][r];
	return cache[n][r] = bino2(n - 1, r-1) + bino2(n - 1, r);
}
```

위에서 보면 알다시피 먼저 만들어놓은 cache메모리에 미리 계산한 값을 저장함으로써 완전탐색기법보다 빠른 속도로 계산이 가능하다.

다음의 문제를 살펴보자

<img src = "https://algospot.com/media/judge-attachments/3a3560eb4194bc927e325514b88468df/jumpgame.png">

땅따먹기를 하다 질린 재하와 영훈이는 땅따먹기의 변종인 새로운 게임을 하기로 했습니다. 이 게임은 그림과 같이 n*n 크기의 격자에 각 1부터 9 사이의 정수를 쓴 상태로 시작합니다. 각 차례인 사람은 맨 왼쪽 윗 칸에서 시작해 외발로 뛰어서 오른쪽 아래 칸으로 내려가야 합니다. 이 때 각 칸에 적혀 있는 숫자만큼 오른쪽이나 아래 칸으로 움직일 수 있으며, 중간에 게임판 밖으로 벗어나면 안 됩니다.

균형을 잃어서 다른 발로 서거나 넘어져도 게임에서 집니다만, 재하와 영훈이는 젊고 활기차기 때문에 외발로 뛰어다니는 것은 아무것도 아닙니다. 다만 걱정되는 것은 주어진 게임판에 시작점에서 끝점으로 가는 방법이 존재하지 않을 수도 있다는 것입니다. 예를 들어 그림 (a)의 게임판에서는 사각형으로 표시된 칸들을 통해 끝에 도달할 수 있지만, 숫자가 하나 바뀐 그림 (b)에서는 그럴 수가 없습니다.

게임판이 주어질 때 왼쪽 위의 시작점에서 오른쪽 아래의 시작점에 도달할 수 있는 방법이 있는지 확인하는 프로그램을 작성하세요.

### 입력

입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 격자의 크기 n(2 <= n <= 100)이 주어지고, 그 후 n줄에 각 n개의 숫자로 왼쪽 위부터 각 칸에 쓰인 숫자들이 주어집니다. 오른쪽 아래 있는 끝 점 위치에는 0이 주어집니다.

### 출력

각 테스트 케이스마다 한 줄로, 시작점에서 끝 점으로 도달할 수 있을 경우 "YES"를, 아닐 경우 "NO"를 출력합니다. (따옴표 제외)

### 예제 입력

	2
	7
	2 5 1 6 1 4 1
	6 1 1 2 2 9 3
	7 2 3 2 1 3 1
	1 1 3 1 7 1 2
	4 1 2 3 4 1 2
	3 3 1 2 3 4 1
	1 5 2 9 4 7 0
	7
	2 5 1 6 1 4 1
	6 1 1 2 2 9 3
	7 2 3 2 1 3 1
	1 1 3 1 7 1 2
	4 1 2 3 4 1 3
	3 3 1 2 3 4 1
	1 5 2 9 4 7 0 
### 예제 출력
	YES
	NO

### 문제해결

처음에 이 문제를 풀려면 완전 탐색기법을 구현해본다. 그 다음 노가다로 동적 계산법이 가능한지 안한지를 판단해 보았다.

다음의 코드를 확인해보자.

```
int n, board[100][100];

bool jump(int x, int y) {
	if (y >= n || x >= n) return false;
	if (y == n && x == n) return true;
	int jumpSize = board[y][x];
	return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```
이때 재귀부분을 확인하게 되면 같은 부분 즉, 이미 이전에 계산했던 부분에 다시 도달하게 되면 다시 계산하는 매우 불편한 구조를 하고 있는것을 확인할 수 있다.

예를들어 첫번째 발판을 밟았다고 할 때 만약 오른쪽에서 세번째 3을 밟게 된다면, 다음 경우에 같은 위치에 오게된다면 또한번 계산해야 된다. 이부분을 제하고자 동적 계산법을 사용해 볼 수 있었다.

다음의 코드를 살펴보자.

```
int cache[1000][1000];

bool jump2(int x, int y) {
	if (y >= n || x >= n) return false;
	if (y == n && x == n) return true;
	int& ret = cache[y][x];
	if (ret != -1)
		return ret;
	int jumpSize = board[y][x];
	return ret = jump2(y + jumpSize, x) || jump2(y, x + jumpSize);
}
```
여기서 cache라는 메모리를 미리 만들어 둠으로써 한번 계산된 값은 무조건 cache배열에 저장되게 된다. 이처럼 한번 계산했던 값을 기억함으로써 함수 호출을 한번만 할 수 있게 만들어 주는 프로그램이 동적 계획법이다.

### 마치며

처음엔 재귀함수만을 알고 있을 때는 완전 탐색 기법이 매우 좋지만 조금더 빠른 방법은 없나 생각 했었다. 하지만 공부함에따라 완전 탐색기법의 상위급인 동적 계획법을 확인하고 이부분을 좀더 공부하고 빠르게 떠올릴 수 있다면 다음 계산할 시에 더욱 빠른 연산을 할 수 있을 것으로 예상합니다.